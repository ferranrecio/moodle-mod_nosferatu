{"version":3,"file":"intro01.min.js","sources":["../../../src/local/templatecomponents/intro01.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * This file is just an example to illustrate how to create a reactive app in Moodle.\n * For didactic purposes, all the logic of this app is in the same file. However, in a real\n * scenario, you should split the logic in different files and import them here. We will see\n * how to do this after the introduction samples.\n *\n * @module     mod_nosferatu/local/templatecomponents/intro01\n * @copyright  2024 Ferran Recio <ferran@moodle.com>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\n// First thing first. We need to import all the necessary dependencies. All of them\n// are provided by core/reactive.\nimport {BaseComponent, Reactive} from 'core/reactive';\n\n// Reactivity is based on browser events. Moodle coding style forces us to declare all\n// plugin events and dispatchers in a specific way. This is not unique to reactive apps\n// but to all plugins with custom events.\nimport {eventTypes, notifyModNosferatuStateUpdated} from 'mod_nosferatu/events';\n\n// Usually modules have a single init method. However, this will go against the example narrative\n// because it will require to go scroll up and down at a certain steps. I want you focused in the\n// reactive part so we will push here any logic we want to execute on the init method.\nconst onInit = [];\n\n/**\n * Dirty trick to have a dynamic init method.\n *\n * This is just an easy way to use a dynamic init method. It is not realted to reactivity at all.\n * Think of it as a way to keep the narrative clean.\n */\nexport const init = function() {\n    onInit.forEach(\n        method => method()\n    );\n};\n\n\n// Now we have everything we need to start creating our first reactive component.\n\n// In this example you will learn how to:\n// - Instantiate a reactive module to store the frontend state data\n// - Delegate UI logic to components that react to the state changes\n// - Implement mutations to alter the state from the components.\n// - Capture user interactions to trigger mutations.\n\n// === STEP 1: building our initial state ===\n\n// This is the most abstract part of the process. In a reactive pattern, all related UI component uses\n// the same data structure to decide how to present things. This data structure is called reactive \"state\".\n// Any change on that structure will be notified to the components so they can alter a part of the UI.\n//\n// Working with a reactive state has many advantages over the traditional approach:\n//\n// - More than one component can represent the same part of the state but they don't need to be\n//   aware each other.\n// - User interactions won't change the HTML elements but only will request state data changes. We will\n//   call those requests \"mutations\" from now on.\n// - We can add more components at any moment, even adding alternative ways to do the same mutation\n//   because the refreshing logic and the mutation one are independent.\n\n// Ok, enough theory for not. Let's build our first state. For this first example will be use a simple\n// counter. For technical reasons, our state data can only store:\n// - Sets of objects with id attributes\n// - Objects with attributes\n\n// So, we will use an object to store the counter value.\n\nconst state = {\n    'info': {\n        counter: 0,\n    },\n};\n\n// === STEP 2: the reactive instance ===\n\n// Many reactive components may coexist in the same page. In our example, the course editor has it's own\n// reactive components, while our two components has their own. However, each components watches a specific\n// state data so they won't interfere with one another.\n\n// To ensure each component works as expected. All components must be \"registered\" in a specfici reactive\n// instance. A reactive instance is an object that handle all the watchers logic and contains the current\n// state data.\n\n// No matter how small your applications is, it is almost sure you will need shared methods between components.\n// For this reason, it is highly recommended you create your own reactive class that extends the base one.\n\nclass MyReactive extends Reactive {\n    // Here you can add your own methods.\n}\n\nconst myReactiveInstance = new MyReactive({\n    // The name of the instance is used to identify the instance in debugging tools.\n    name: 'mod_nosferatu_example',\n\n    // As mentioned before, we need to use the plugin custom events.\n    eventName: eventTypes.modNosferatuStateUpdated,\n    eventDispatch: notifyModNosferatuStateUpdated,\n\n    // In our case we also include the initial state, but it is not required to create an instance because, in\n    // most cases we will need to call the backend to get the initial state when the page is already served.\n    state,\n\n    // The are other options you can use in creation. A few lines below you will see we add state mutations\n    // to allow components to ask for state changes. In most cases the available mutations are clear from the\n    // beginning, so it is common to pass the \"mutations\" at the moment we create the reactive instance.\n    // You will se how to do this in the next examples. Future examples will show you other options.\n});\n\n// === STEP 3: the first component ===\n\n// Now we have everything ready to build our first component. That component will watch any change in the\n// the state data and update the UI.\n\n// For this first compoment we will use the base component class. This class is the most basic one and\n// it is used to create components that only need to watch the state data. Don't worry if you find\n// some of the details of this class a bit confusing. In next example we will simplify the process\n// by using TemplateComponents.\n\n// This class will to the job. To understand how a component works you need to understand the component\n// lifecycle.\n// - create: before the component is registered. This method is used to define\n//           the main component attributes.\n//\n// - getWatchers: at the moment the reactive instance is registering the watchers. This method\n//                return a list of state changes handlers. We will see in a minute.\n//\n// - stateReady: when the reactive instance has the initial state state_loaded. Is important to note\n//               that this method will be called even if the component is registered after the initial\n//               is loaded. For all purposes, this method is the equivalent of page ready for components.\n//\n// - unregister: if the component is unregistered from the reactive instance\n//\n// - destroy: if the component is removed form the page\n\nclass FirstComponent extends BaseComponent {\n    /**\n     * It is important to follow some conventions while you write components. This way all components\n     * will be implemented in a similar way and anybody will be able to understand how it works.\n     *\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        // This is an optional name for the debugging messages.\n        this.name = 'mod_nosferatu_FirstComponent';\n        // If you need local attributes like ids os something it should be initialized here.\n    }\n\n    /**\n     * We want to update the counter every time the value change. To do this we need\n     * to define a watcher.\n     *\n     * @returns {Array} of watchers\n     */\n    getWatchers() {\n        return [\n            // For this first example we will watch the whole state. This means that any change in the state\n            // will trigger the handler. In a real scenario, you should watch only the part of the state that\n            // affects the component. But we will see this in the compoment optimization example.\n            {watch: `state:updated`, handler: this._refreshCounter},\n        ];\n    }\n\n    /**\n     * We will trigger that method any time a person data changes. This method is used by stateReady\n     * but, most important, to watch the state. Any watcher receive an object with:\n     * - element: the afected element\n     * - state: the full state object\n     *\n     * @param {object} param the watcher param.\n     * @param {object} param.state the person structure.\n     */\n    _refreshCounter({state}) {\n        // The base compoment class provides a method to get any internal element\n        // having data-mdl-ref attribute. The method also guarantees that the element\n        // is owned by the component and it is not part of any sub component.\n        this.getReference('count').innerHTML = state.info.counter;\n    }\n}\n\n// As you may notice, we don't define any constructor method. This is because the base component class\n// has a default constructor that will call the create method. Let's instantiate the component.\n\n// To instantiate a new compoment you need to provide the following:\n// - selector: ALL components must have a main element. The easiest way to do this is by passing\n//             the element query selector as \"selector\".\n// - reactive: the reactive instance to register to. In our case we will use the myReactiveInstance.\n\n// Remember, we ure using the \"onInit\" for pedagogical reasons. In a real scenario you should\n// the component instantiation will be done on the component  mustache file directly.\nonInit.push(\n    () => {\n        new FirstComponent({\n            selector: '#exampleApp [data-mdl-region=\"exampleComponent1\"]',\n            reactive: myReactiveInstance,\n        });\n    }\n);\n\n// === STEP 4: your first mutation ===\n\n// As you may notice, components are quite limited if they cannot alter the state. That is because the component\n// logic should be fully focussed in reacting to the state changes. If the components start messing around\n// with the state as they pleased, you will end up with tons of components methods doing the same state\n// modifications.\n//\n// To prevent this from happening, all state changes (and I mean ALL, even the smallest ones) are defined as\n// \"mutation\" methods in the reactive instance. This way, when any component wants to trigger a state change\n// it must do:\n//\n// this.reactive.dispatch('MUTATION_NAME', param1, param2....);\n//\n// In our case, this will be something like:\n//\n// this.reactive.dispatch('increment', number);\n//\n// When any component wants to \"increment\" the counter, they will do it in the same exact way.\n// Note the dispatch method is defined as async because it usually does ajax calls.\n\n// Perfect, enough theory for now. Let's create our mutation class. We only need an increment\n// method. However, you will note the way to do it is quite peculiar.\n\n/**\n * Our mutation class.\n *\n * Keep all the mutations in a single class (in its own module) is a best practice. However, for big projects\n * it is possible to split the mutations in different classes.\n */\nclass Mutations {\n    /**\n     * Increment the counter.\n     *\n     * All mutations receive a StateManager object as a first parameter. With this object the mutation\n     * can access the state (stateManager.state) but also set the read mode (statemanager.setReadOnly(true|false)).\n     * In next steps we will see some other stateManager features. But for now you don't need them.\n     *\n     * @param {StateManager} stateManager the current state\n     * @param {int} amount the increment amount.\n     */\n    increment(stateManager, amount) {\n        // The first thing we need to do is get the current state.\n        const state = stateManager.state;\n        // State is always on read mode. To change any value first we need to unlock it.\n        stateManager.setReadOnly(false);\n        // Now we do as many state changes as we need.\n        state.info.counter += amount;\n        // All mutations should restore the read mode. This will trigger all the reactive events.\n        stateManager.setReadOnly(true);\n    }\n}\n\n// Once we have the class defined, we just need to register it in the reactive instance.\n// In a normal scenario, you will do this when you create the reactive instance by passing\n// a \"mutations\" attribute.\nmyReactiveInstance.setMutations(new Mutations());\n\n// Perfect. Now it is time to test it. Execute this command in the console:\n//\n// M.reactive.mod_nosferatu_example.dispatch('increment', 2);\n//\n// If all goes as expected, the counter on the first compoment should increase by 2.\n\n\n// === STEP 5: add a second component to execute the mutation ===\n\n// This is similar to the first component. The only difference is that this component will\n// capture some user interaction and dispatch the mutation.\n\nclass SecondComponent extends BaseComponent {\n    /**\n     * All the component definition should be initialized on the \"create\" method.\n     */\n    create() {\n        // This is an optional name for the debugging messages.\n        this.name = 'mod_nosferatu_SecondComponent';\n        // If necessary, you can add local attributes here.\n    }\n\n    /**\n     * Initial state ready method.\n     *\n     * Remember, this is our equivalent of document ready for components.\n     */\n    stateReady() {\n        // We can access the component main element at any time using this.element.\n        this.addEventListener(\n            this.element,\n            'click',\n            this._handleClick\n        );\n        // As you may notice, we use \"this.addEventListener\" instead of\n        // \"this.element.addEventListener\" and there are a very good\n        // reasons to do it that way:\n        //\n        // 1. A component is something that could be unregisterd at any moment (we will see later),\n        //    when a component is unregisterd, all listeners added using this.addEventListener will\n        //    be also removed automatically.\n        //\n        // 2. If at some point you need to stop listening an event, you can use this.removeEventListener\n        //    without worring about binding problems (quite common when you use object oriented code\n        //    with JS events).\n        //\n        // 3. The \"this\" inside your listeners will always the component instance, not a DOM element.\n        //    this way you can reuse the same methods for other uses, not only as listeners. And more\n        //    important, in all your component methods the \"this\" value will be consistent.\n    }\n\n    /**\n     * Our click handler.\n     *\n     * We should delegate as much events as possible to the main element. In next examples we will see\n     * how the component HTML can change at any moment using virtual DOM and how this can affect the\n     * event listeners. Only the this.element is guaranteed to be always there.\n     *\n     * @param {Event} event the click event\n     */\n    _handleClick(event) {\n        const clickedElement = event.target.closest('[data-mdl-nosferatu-action=\"increment\"]');\n        if (clickedElement) {\n            event.preventDefault();\n            this.reactive.dispatch(\n                'increment',\n                Number.parseInt(clickedElement.dataset.mdlNosferatuAmount),\n            );\n        }\n    }\n\n    // As you may notice, we don't implement the getWatchers method. That is because this component\n    // does not need to watch the state. It's HTML is static.\n}\n\n// I know I already tell you, but the \"onInit\" is just a dirty trick to keep the narrative clean\n// but it not how we will do in a real scenario. In a real scenario you will add the component\n// instantiation in the component mustache file directly.\nonInit.push(\n    () => {\n        new SecondComponent({\n            selector: '#exampleApp [data-mdl-region=\"exampleComponent2\"]',\n            reactive: myReactiveInstance,\n        });\n    }\n);\n\n// That's it! Your first reactive app is ready. Refresh the page and test it.\n\n// In the next example we will see how to use the TemplateComponent class to simplify\n// even more the code. Return to the page to get more information about how works beneath the hood.\n"],"names":["onInit","forEach","method","MyReactive","Reactive","myReactiveInstance","name","eventName","eventTypes","modNosferatuStateUpdated","eventDispatch","notifyModNosferatuStateUpdated","state","counter","FirstComponent","BaseComponent","create","getWatchers","watch","handler","this","_refreshCounter","getReference","innerHTML","info","push","selector","reactive","setMutations","increment","stateManager","amount","setReadOnly","SecondComponent","stateReady","addEventListener","element","_handleClick","event","clickedElement","target","closest","preventDefault","dispatch","Number","parseInt","dataset","mdlNosferatuAmount"],"mappings":";;;;;;;;;;;MAsCMA,OAAS,iBAQK,WAChBA,OAAOC,SACHC,QAAUA,kBAsDZC,mBAAmBC,0BAInBC,mBAAqB,IAAIF,WAAW,CAEtCG,KAAM,wBAGNC,UAAWC,mBAAWC,yBACtBC,cAAeC,uCAIfC,MAjCU,MACF,CACJC,QAAS,YAiEXC,uBAAuBC,wBAOzBC,cAESV,KAAO,+BAUhBW,oBACW,CAIH,CAACC,sBAAwBC,QAASC,KAAKC,kBAa/CA,0BAAgBT,MAACA,iBAIRU,aAAa,SAASC,UAAYX,MAAMY,KAAKX,SAc1Db,OAAOyB,MACH,SACQX,eAAe,CACfY,SAAU,oDACVC,SAAUtB,wBA4DtBA,mBAAmBuB,aAAa,UAf5BC,UAAUC,aAAcC,cAEdnB,MAAQkB,aAAalB,MAE3BkB,aAAaE,aAAY,GAEzBpB,MAAMY,KAAKX,SAAWkB,OAEtBD,aAAaE,aAAY,YAqB3BC,wBAAwBlB,wBAI1BC,cAESV,KAAO,gCAShB4B,kBAESC,iBACDf,KAAKgB,QACL,QACAhB,KAAKiB,cA4BbA,aAAaC,aACHC,eAAiBD,MAAME,OAAOC,QAAQ,2CACxCF,iBACAD,MAAMI,sBACDf,SAASgB,SACV,YACAC,OAAOC,SAASN,eAAeO,QAAQC,uBAYvD/C,OAAOyB,MACH,SACQQ,gBAAgB,CAChBP,SAAU,oDACVC,SAAUtB"}